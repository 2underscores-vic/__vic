<chapter>
<title><tt>__vic/tchar.h</tt></title>

<p>Generic functions to manipulate C-strings regardless of the underlying
char-type, like <tt>std::char_traits&lt;></tt>. All the functions are located
within <tt>__vic::tchar</tt> namespace.</p>

<chapter>
<title>Functions</title>

<code-block lang="C++"><![CDATA[
namespace tchar {

template<class charT>
size_t length(const charT *str);

template<class charT>
const charT *end(const charT *str);

template<class charT>
charT *end(charT *str);

template<class charT>
int compare(const charT *str1, const charT *str2);

template<class charT>
charT *copy(charT *dest, const charT *src);

template<class charT>
charT *move(charT *dest, const charT *src);

template<class charT>
charT *concat(charT *dest, const charT *src);

template<class charT>
const charT *find(const charT *str, charT ch);

template<class charT>
charT *find(charT *str, charT ch);

template<class charT>
const charT *find(const charT *str, const charT *sub);

template<class charT>
charT *find(charT *str, const charT *sub);

template<class charT>
const charT *rfind(const charT *str, charT ch);

template<class charT>
charT *rfind(charT *str, charT ch);

template<class charT, class Pred>
const charT *find_if(const charT *str, Pred pred);

template<class charT, class Pred>
charT *find_if(charT *str, Pred pred);

template<class charT, class Pred>
const charT *find_if_not(const charT *str, Pred pred);

template<class charT, class Pred>
charT *find_if_not(charT *str, Pred pred);

template<class charT, class Pred>
const charT *rfind_if(const charT *str, Pred pred);

template<class charT, class Pred>
charT *rfind_if(charT *str, Pred pred);

template<class charT, class Pred>
const charT *rfind_if_not(const charT *str, Pred pred);

template<class charT, class Pred>
charT *rfind_if_not(charT *str, Pred pred);

template<class charT>
const charT *find_first_of(const charT *str, const charT *set);

template<class charT>
charT *find_first_of(charT *str, const charT *set);

template<class charT>
const charT *find_first_not_of(const charT *str, const charT *set);

template<class charT>
charT *find_first_not_of(charT *str, const charT *set);

template<class charT>
const charT *find_last_of(const charT *str, const charT *set);

template<class charT>
charT *find_last_of(charT *str, const charT *set);

template<class charT>
const charT *find_last_not_of(const charT *str, const charT *set);

template<class charT>
charT *find_last_not_of(charT *str, const charT *set);

template<class charT>
const charT *skip(const charT *str, charT ch);

template<class charT>
charT *skip(charT *str, charT ch);

template<class charT>
const charT *rskip(const charT *str, charT ch);

template<class charT>
charT *rskip(charT *str, charT ch);

} // namespace
]]></code-block>

<p>Most of the functions are just generic redirectors to calls like
<tt>strcpy</tt>, <tt>wcscpy</tt>, et al. Searching functions have more
intelligible names that ones in the C-library and unified parameters: they
always take pointers and never indices. Also the set of the functions is
complemented with "logically symmetrical" ones. Searching functions return
<tt>nullptr</tt> in case of failure.</p>

<p>Below the list of the function names with the description is presented.
Standard library counterparts are showed in the brackets if exist.</p>

<synopsis>
<prototype>length  [strlen/wcslen]</prototype>
<p>String length in elements.</p>
</synopsis>

<synopsis>
<prototype>end  [strchr(str, '\0')/wcschr(str, L'\0')]</prototype>
<p>Pointer to the NUL-terminator.</p>
</synopsis>

<synopsis>
<prototype>compare  [strcmp/wcscmp]</prototype>
<p>Compare two strings.</p>
</synopsis>

<synopsis>
<prototype>copy  [strcpy/wcscpy]</prototype>
<p>Copy string.</p>
</synopsis>

<synopsis>
<prototype>move  [memmove]</prototype>
<p>Move the string in memory.</p>
</synopsis>

<synopsis>
<prototype>concat  [strcat/wcscat]</prototype>
<p>Concatenate two strings.</p>
</synopsis>

<synopsis>
<prototype>find  [strchr/wcschr/strstr/wcsstr]</prototype>
<p>Find the first occurrence of the character or substring.</p>
</synopsis>

<synopsis>
<prototype>rfind  [strrchr/wcsrchr]</prototype>
<p>Find the last occurrence of the character.</p>
</synopsis>

<synopsis>
<prototype>find_if</prototype>
<p>Find the first occurrence of the character that satisfies the specified
predicate.</p>
</synopsis>

<synopsis>
<prototype>find_if_not</prototype>
<p>Find the first occurrence of the character that doesn't satisfy the
specified predicate.</p>
</synopsis>

<synopsis>
<prototype>rfind_if</prototype>
<p>Find the last occurrence of the character that satisfies the specified
predicate.</p>
</synopsis>

<synopsis>
<prototype>rfind_if_not</prototype>
<p>Find the last occurrence of the character that doesn't satisfy the specified
predicate.</p>
</synopsis>

<synopsis>
<prototype>find_first_of  [strpbrk/wcspbrk]</prototype>
<p>Find the first occurrence of the character from the specified set.</p>
</synopsis>

<synopsis>
<prototype>find_first_not_of  [strspn/wcsspn]</prototype>
<p>Find the first occurrence of the character absent in the specified set.</p>
</synopsis>

<synopsis>
<prototype>find_last_of</prototype>
<p>Find the last occurrence of the character from the specified set.</p>
</synopsis>

<synopsis>
<prototype>find_last_not_of</prototype>
<p>Find the last occurrence of the character absent in the specified set.</p>
</synopsis>

<synopsis>
<prototype>skip</prototype>
<p>Skip all occurrences of the specified character and return the pointer.
Pointer to NUL-terminator is returned if no other characters is presented.</p>
</synopsis>

<section><title>Example</title>
<code-block lang="C++"><![CDATA[
template<class charT>
charT *generic_dup(const charT *st)
{
    namespace tchar = __vic::tchar;

    charT *st_copy = new charT[tchar::length(st) + 1];
    tchar::copy(st_copy, st);
    return st_copy;
}
]]></code-block>
</section>

</chapter>

</chapter>
