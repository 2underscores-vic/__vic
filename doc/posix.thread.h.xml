<chapter>
<title><tt>__vic/posix/thread.h</tt></title>

<p>C++ wrappers for Pthreads.</p>


<chapter>
<title><tt>posix::this_thread</tt></title>

<code-block lang="C++"><![CDATA[
namespace posix::this_thread
{
    int sigwait(const ::sigset_t &set);
    ::siginfo_t sigwaitinfo(const ::sigset_t &set);

    void block_signals(const ::sigset_t &mask,
                                ::sigset_t *oldmask = nullptr);
    void unblock_signals(const ::sigset_t &mask,
                                ::sigset_t *oldmask = nullptr);
    void set_sigmask(const ::sigset_t &mask, ::sigset_t *oldmask = nullptr);
}
]]></code-block>

<p>Set of the functions to control the current thread.</p>

<synopsis>
<prototype>int sigwait(const ::sigset_t &amp;set)</prototype>
<p>Suspends the current thread until the signal from <tt>set</tt> is received.
Received signal is returned as a result.</p>
</synopsis>

<synopsis>
<prototype>::siginfo_t sigwaitinfo(const ::sigset_t &amp;set)</prototype>
<p>Counterpart of <tt>sigwait()</tt> but returns additional information about
the received signal. The signal is returned in <tt>si_signo</tt> field.</p>
<note>The function is not interrupted by signal handlers as opposed to the
system call of the same name.</note>
<note><tt>::sigaction()</tt> with <tt>sa_flags</tt> containing
<tt>SA_SIGINFO</tt> has to be called for each signal from <tt>set</tt> before
usage! Otherwise the returned value will contain garbage!</note>
</synopsis>

<synopsis>
<prototype>void block_signals(const ::sigset_t &amp;mask, ::sigset_t *oldmask = nullptr)</prototype>
<p>Adds the signals from the set to the blocked ones in the calling thread.</p>
</synopsis>

<synopsis>
<prototype>void unblock_signals(const ::sigset_t &amp;mask, ::sigset_t *oldmask = nullptr)</prototype>
<p>Removes the signals from the set from the blocked ones in the calling
thread.</p>
</synopsis>

<synopsis>
<prototype>void set_sigmask(const ::sigset_t &amp;mask, ::sigset_t *oldmask = nullptr)</prototype>
<p>Sets the mask of blocked signals for the calling thread. All signals from
the set are blocked, others - aren't.</p>
</synopsis>

</chapter>


<chapter>
<title><tt>posix::mutex</tt></title>

<code-block lang="C++">
class posix::mutex : private non_copyable
{
public:
    constexpr mutex() noexcept;
    ~mutex();

    void lock();
    bool try_lock();
    bool unlock() noexcept;

    // System-specific handle
    ::pthread_mutex_t *handle();
    const ::pthread_mutex_t *handle() const;
};
</code-block>

<p>Wrapper for plain non-recursive <tt>pthread_mutex</tt>.</p>

<section><title>Usage notes</title>
<p>In most cases explicit usage of <tt>lock()</tt> and <tt>unlock()</tt> should
be avoided. Use class <tt>mutex_lock</tt> to manage locks instead. It provides
exception safety and is handy for usage.</p>
<p>In ะก++11 mode <tt>std::mutex</tt> can be a better alternative.</p>
</section>

<section><title>Class members</title>

<synopsis>
<prototype>constexpr mutex() noexcept</prototype>
<p>Creates unlocked mutex.</p>
</synopsis>

<synopsis>
<prototype>~mutex()</prototype>
<p>Destroys the mutex.</p>
</synopsis>

<synopsis>
<prototype>void lock()</prototype>
<p>Acquires a lock on the mutex. Waits until released if acquired by other
thread at the moment.</p>
</synopsis>

<synopsis>
<prototype>bool try_lock()</prototype>
<p>Tries to lock the mutex. Immediately returns <tt>false</tt> if acquired by
other thread, without waiting.</p>
</synopsis>

<synopsis>
<prototype>bool unlock() noexcept</prototype>
<p>Releases the mutex acquired before. In some cases can return <tt>false</tt>
in case of error, but in general error detection is not guaranteed.</p>
</synopsis>

<synopsis>
<prototype>::pthread_mutex_t *handle()</prototype>
<prototype>const ::pthread_mutex_t *handle() const</prototype>
<p>Returns the native handle of the mutex.</p>
</synopsis>

</section>

<section><title>Example</title>
<p>See posix::mutex_lock.</p>
</section>

</chapter>


<chapter>
<title><tt>posix::mutex_lock</tt></title>

<code-block lang="C++"><![CDATA[
class posix::mutex_lock : private non_copyable, private non_heap_allocatable
{
public:
    enum adopt_t { adopt };

    explicit mutex_lock(posix::mutex &mtx);
    mutex_lock(posix::mutex &mtx, adopt_t);

    explicit mutex_lock(::pthread_mutex_t &mtx);
    mutex_lock(::pthread_mutex_t &mtx, adopt_t);

    ~mutex_lock() noexcept(false);
};
]]></code-block>

<p>Class manages the lock on a mutex. The lock exists while the object is
alive. Can handle <tt>posix::mutex</tt> class objects as well as system
<tt>pthread_mutex_t</tt>.</p>

<section><title>Class members</title>

<synopsis>
<prototype>adopt</prototype>
<p>Constructor tag, suppresses the lock acquisition.</p>
</synopsis>

<synopsis>
<prototype>explicit mutex_lock(posix::mutex &amp;mtx)</prototype>
<prototype>explicit mutex_lock(::pthread_mutex_t &amp;mtx)</prototype>
<p>Locks <tt>mtx</tt>.</p>
</synopsis>

<synopsis>
<prototype>~mutex_lock() noexcept(false)</prototype>
<p>Unlocks <tt>mtx</tt>. Can throw exception in case of error and when there
is no other active exception!</p>
</synopsis>

<synopsis>
<prototype>mutex_lock(posix::mutex &amp;mtx, adopt_t)</prototype>
<prototype>mutex_lock(::pthread_mutex_t &amp;mtx, adopt_t)</prototype>
<p>Adopts already locked <tt>mtx</tt>. See the example.</p>
</synopsis>

</section>

<section><title>Example</title>
<code-block lang="C++">
// Typical usage
void reentrant_function()
{
    static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
    __vic::posix::mutex_lock lock(mtx);
    // Critical section code until the end of the block
    ...
}

// Usage of non-locking constructor
__vic::posix::mutex mtx;
if(mtx.try_lock()) // Try to lock the mutex
{
    // The mutex is successfully locked
    using __vic::posix::mutex_lock;
    mutex_lock lock(mtx, mutex_lock::adopt);
    // Critical section code until the end of the block
    ...
}
else
{
    // The mutex is locked by another thread
    ...
}
</code-block>
</section>

</chapter>


<chapter>
<title><tt>posix::cond_variable</tt></title>

<code-block lang="C++"><![CDATA[
class posix::cond_variable : private non_copyable
{
public:
    constexpr cond_variable() noexcept;
    ~cond_variable();

    void wait(::pthread_mutex_t &m);
    void wait(posix::mutex &m);

    bool wait_until(::pthread_mutex_t &m, const ::timespec &abstime);
    bool wait_until(posix::mutex &m, const ::timespec &abstime);

    void signal();
    void broadcast();

    // C++11-compatible synonyms
    void notify_one() { signal(); }
    void notify_all() { broadcast(); }
};
]]></code-block>

<p>POSIX condition variable.</p>

<note>In ะก++11 mode <tt>std::condition_variable</tt> can be a better
alternative.</note>

<section><title>Class members</title>

<synopsis>
<prototype>cond_variable()</prototype>
<p>Creates the object.</p>
</synopsis>

<synopsis>
<prototype>~cond_variable()</prototype>
<p>Destroys the object.</p>
</synopsis>

<synopsis>
<prototype>void wait(::pthread_mutex_t &amp;m)</prototype>
<prototype>void wait(posix::mutex &amp;m)</prototype>
<p>Block the calling thread and waits for notification.</p>
</synopsis>

<synopsis>
<prototype>bool wait_until(::pthread_mutex_t &amp;m, const ::timespec &amp;abstime)</prototype>
<prototype>bool wait_until(posix::mutex &amp;m, const ::timespec &amp;abstime)</prototype>
<p>As <tt>wait()</tt> but waiting time is restricted by the timeout. Returns
<tt>true</tt> if notifcation was received and <tt>false</tt> if timeout was
expired.</p>
</synopsis>

<synopsis>
<prototype>void signal()</prototype>
<prototype>void notify_one()</prototype>
<p>Notifies one of the waiting threads.</p>
</synopsis>

<synopsis>
<prototype>void broadcast()</prototype>
<prototype>void notify_all()</prototype>
<p>Notifies all waiting threads.</p>
</synopsis>

</section>

</chapter>


</chapter>
